{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport GestureHandler from \"./GestureHandler\";\nimport { TEST_MAX_IF_NOT_NAN } from \"./utils\";\n\nvar DiscreteGestureHandler = function (_GestureHandler) {\n  _inherits(DiscreteGestureHandler, _GestureHandler);\n\n  var _super = _createSuper(DiscreteGestureHandler);\n\n  function DiscreteGestureHandler() {\n    _classCallCheck(this, DiscreteGestureHandler);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(DiscreteGestureHandler, [{\n    key: \"isDiscrete\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"shouldEnableGestureOnSetup\",\n    get: function get() {\n      return true;\n    }\n  }, {\n    key: \"shouldFailUnderCustomCriteria\",\n    value: function shouldFailUnderCustomCriteria(_ref, _ref2) {\n      var x = _ref.x,\n          y = _ref.y,\n          deltaX = _ref.deltaX,\n          deltaY = _ref.deltaY;\n      var maxDeltaX = _ref2.maxDeltaX,\n          maxDeltaY = _ref2.maxDeltaY,\n          maxDistSq = _ref2.maxDistSq,\n          shouldCancelWhenOutside = _ref2.shouldCancelWhenOutside;\n\n      if (shouldCancelWhenOutside) {\n        if (!this.isPointInView({\n          x: x,\n          y: y\n        })) {\n          return true;\n        }\n      }\n\n      return TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) || TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq);\n    }\n  }, {\n    key: \"transformNativeEvent\",\n    value: function transformNativeEvent(_ref3) {\n      var _ref3$center = _ref3.center,\n          x = _ref3$center.x,\n          y = _ref3$center.y;\n      var rect = this.view.getBoundingClientRect();\n      return {\n        absoluteX: x,\n        absoluteY: y,\n        x: x - rect.left,\n        y: y - rect.top\n      };\n    }\n  }, {\n    key: \"isGestureEnabledForEvent\",\n    value: function isGestureEnabledForEvent(_ref4, _recognizer, _ref5) {\n      var minPointers = _ref4.minPointers,\n          maxPointers = _ref4.maxPointers,\n          maxDeltaX = _ref4.maxDeltaX,\n          maxDeltaY = _ref4.maxDeltaY,\n          maxDistSq = _ref4.maxDistSq,\n          shouldCancelWhenOutside = _ref4.shouldCancelWhenOutside;\n      var pointerLength = _ref5.maxPointers,\n          center = _ref5.center,\n          deltaX = _ref5.deltaX,\n          deltaY = _ref5.deltaY;\n      var validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n\n      if (this.shouldFailUnderCustomCriteria(_objectSpread(_objectSpread({}, center), {}, {\n        deltaX: deltaX,\n        deltaY: deltaY\n      }), {\n        maxDeltaX: maxDeltaX,\n        maxDeltaY: maxDeltaY,\n        maxDistSq: maxDistSq,\n        shouldCancelWhenOutside: shouldCancelWhenOutside\n      }) || !validPointerCount && this.isGestureRunning) {\n        return {\n          failed: true\n        };\n      }\n\n      return {\n        success: validPointerCount\n      };\n    }\n  }]);\n\n  return DiscreteGestureHandler;\n}(GestureHandler);\n\nexport default DiscreteGestureHandler;","map":{"version":3,"names":["GestureHandler","TEST_MAX_IF_NOT_NAN","DiscreteGestureHandler","x","y","deltaX","deltaY","maxDeltaX","maxDeltaY","maxDistSq","shouldCancelWhenOutside","isPointInView","Math","abs","center","rect","view","getBoundingClientRect","absoluteX","absoluteY","left","top","_recognizer","minPointers","maxPointers","pointerLength","validPointerCount","shouldFailUnderCustomCriteria","isGestureRunning","failed","success"],"sources":["D:/EquipmentBorrowingSystemApp/node_modules/react-native-gesture-handler/dist/src/web/DiscreteGestureHandler.js"],"sourcesContent":["/* eslint-disable eslint-comments/no-unlimited-disable */\n/* eslint-disable */\nimport GestureHandler from './GestureHandler';\nimport { TEST_MAX_IF_NOT_NAN } from './utils';\nclass DiscreteGestureHandler extends GestureHandler {\n    get isDiscrete() {\n        return true;\n    }\n    get shouldEnableGestureOnSetup() {\n        return true;\n    }\n    shouldFailUnderCustomCriteria({ x, y, deltaX, deltaY }, { maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside }) {\n        if (shouldCancelWhenOutside) {\n            if (!this.isPointInView({ x, y })) {\n                return true;\n            }\n        }\n        return (TEST_MAX_IF_NOT_NAN(Math.abs(deltaX), maxDeltaX) ||\n            TEST_MAX_IF_NOT_NAN(Math.abs(deltaY), maxDeltaY) ||\n            TEST_MAX_IF_NOT_NAN(Math.abs(deltaY * deltaY + deltaX * deltaX), maxDistSq));\n    }\n    transformNativeEvent({ center: { x, y } }) {\n        // @ts-ignore FIXME(TS)\n        const rect = this.view.getBoundingClientRect();\n        return {\n            absoluteX: x,\n            absoluteY: y,\n            x: x - rect.left,\n            y: y - rect.top,\n        };\n    }\n    isGestureEnabledForEvent({ minPointers, maxPointers, maxDeltaX, maxDeltaY, maxDistSq, shouldCancelWhenOutside, }, _recognizer, { maxPointers: pointerLength, center, deltaX, deltaY }) {\n        const validPointerCount = pointerLength >= minPointers && pointerLength <= maxPointers;\n        if (this.shouldFailUnderCustomCriteria({ ...center, deltaX, deltaY }, {\n            maxDeltaX,\n            maxDeltaY,\n            maxDistSq,\n            shouldCancelWhenOutside,\n        }) ||\n            // A user probably won't land a multi-pointer tap on the first tick (so we cannot just cancel each time)\n            // but if the gesture is running and the user adds or subtracts another pointer then it should fail.\n            (!validPointerCount && this.isGestureRunning)) {\n            return { failed: true };\n        }\n        return { success: validPointerCount };\n    }\n}\nexport default DiscreteGestureHandler;\n"],"mappings":";;;;;;;;;;;;;;;AAEA,OAAOA,cAAP;AACA,SAASC,mBAAT;;IACMC,sB;;;;;;;;;;;;;SACF,eAAiB;MACb,OAAO,IAAP;IACH;;;SACD,eAAiC;MAC7B,OAAO,IAAP;IACH;;;WACD,oDAAsH;MAAA,IAAtFC,CAAsF,QAAtFA,CAAsF;MAAA,IAAnFC,CAAmF,QAAnFA,CAAmF;MAAA,IAAhFC,MAAgF,QAAhFA,MAAgF;MAAA,IAAxEC,MAAwE,QAAxEA,MAAwE;MAAA,IAA5DC,SAA4D,SAA5DA,SAA4D;MAAA,IAAjDC,SAAiD,SAAjDA,SAAiD;MAAA,IAAtCC,SAAsC,SAAtCA,SAAsC;MAAA,IAA3BC,uBAA2B,SAA3BA,uBAA2B;;MAClH,IAAIA,uBAAJ,EAA6B;QACzB,IAAI,CAAC,KAAKC,aAAL,CAAmB;UAAER,CAAC,EAADA,CAAF;UAAKC,CAAC,EAADA;QAAL,CAAnB,CAAL,EAAmC;UAC/B,OAAO,IAAP;QACH;MACJ;;MACD,OAAQH,mBAAmB,CAACW,IAAI,CAACC,GAAL,CAASR,MAAT,CAAD,EAAmBE,SAAnB,CAAnB,IACJN,mBAAmB,CAACW,IAAI,CAACC,GAAL,CAASP,MAAT,CAAD,EAAmBE,SAAnB,CADf,IAEJP,mBAAmB,CAACW,IAAI,CAACC,GAAL,CAASP,MAAM,GAAGA,MAAT,GAAkBD,MAAM,GAAGA,MAApC,CAAD,EAA8CI,SAA9C,CAFvB;IAGH;;;WACD,qCAA2C;MAAA,yBAApBK,MAAoB;MAAA,IAAVX,CAAU,gBAAVA,CAAU;MAAA,IAAPC,CAAO,gBAAPA,CAAO;MAEvC,IAAMW,IAAI,GAAG,KAAKC,IAAL,CAAUC,qBAAV,EAAb;MACA,OAAO;QACHC,SAAS,EAAEf,CADR;QAEHgB,SAAS,EAAEf,CAFR;QAGHD,CAAC,EAAEA,CAAC,GAAGY,IAAI,CAACK,IAHT;QAIHhB,CAAC,EAAEA,CAAC,GAAGW,IAAI,CAACM;MAJT,CAAP;IAMH;;;WACD,yCAAkHC,WAAlH,SAAuL;MAAA,IAA5JC,WAA4J,SAA5JA,WAA4J;MAAA,IAA/IC,WAA+I,SAA/IA,WAA+I;MAAA,IAAlIjB,SAAkI,SAAlIA,SAAkI;MAAA,IAAvHC,SAAuH,SAAvHA,SAAuH;MAAA,IAA5GC,SAA4G,SAA5GA,SAA4G;MAAA,IAAjGC,uBAAiG,SAAjGA,uBAAiG;MAAA,IAAzCe,aAAyC,SAAtDD,WAAsD;MAAA,IAA1BV,MAA0B,SAA1BA,MAA0B;MAAA,IAAlBT,MAAkB,SAAlBA,MAAkB;MAAA,IAAVC,MAAU,SAAVA,MAAU;MACnL,IAAMoB,iBAAiB,GAAGD,aAAa,IAAIF,WAAjB,IAAgCE,aAAa,IAAID,WAA3E;;MACA,IAAI,KAAKG,6BAAL,iCAAwCb,MAAxC;QAAgDT,MAAM,EAANA,MAAhD;QAAwDC,MAAM,EAANA;MAAxD,IAAkE;QAClEC,SAAS,EAATA,SADkE;QAElEC,SAAS,EAATA,SAFkE;QAGlEC,SAAS,EAATA,SAHkE;QAIlEC,uBAAuB,EAAvBA;MAJkE,CAAlE,KAQC,CAACgB,iBAAD,IAAsB,KAAKE,gBARhC,EAQmD;QAC/C,OAAO;UAAEC,MAAM,EAAE;QAAV,CAAP;MACH;;MACD,OAAO;QAAEC,OAAO,EAAEJ;MAAX,CAAP;IACH;;;;EAzCgC1B,c;;AA2CrC,eAAeE,sBAAf"},"metadata":{},"sourceType":"module"}